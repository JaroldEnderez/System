import React, { Component } from "react";
import Grid from "./grid/Grid";
import TimeScale from "./TimeScale";
import Chart from "./chart/Chart";
import Sidebar from "./sidebar/Sidebar";
import Tooltip from "../wx/Tooltip";
import IconButton from "../wx/IconButton";

import { normalizeColumns } from "@dhtmlx/trial-lib-gantt";
import { ReactLocalData, ReactLocalState } from "../state/local";

import css from "./Gantt.module.css";

let iid = 1;
const uid = () => {
  return iid++;
};

class Gantt extends Component {
  constructor(props) {
    super();

    const emit = (name, data) => {
      if (props[name]) props[name](data);
    };

    this.store = new ReactLocalData(this, emit);
    this.store.init(props);

    this.state = new ReactLocalState(this, emit);
    this.action = this.state.actions(this.store);

    const columnsData = normalizeColumns(props.columns);

    if (props.store) props.store(this.store);

    this.state = {
      columnsData,
      compactMode: false,
      ...this.state.getValues(),
    };

    this.compactWith = 650;
    if (typeof ResizeObserver !== "undefined") {
      this.ro = new ResizeObserver((a) => this.resize(a));
      this.ro.observe(document.body);
    }
  }

  componentDidMount() {
    this.store.mounted();
  }

  componentDidUpdate(prevProps) {
    onPropsChange(prevProps, this.props, () => this.store.init(this.props), {
      tasks: 1,
      links: 1,
      start: 1,
      end: 1,
      scales: 1,
      cellWidth: 1,
      cellHeight: 1,
      scaleHeight: 1,
    });
  }

  componentWillUnmount() {
    this.ro.disconnect();
  }

  resize(data) {
    for (let obj of data) {
      if (obj.target === document.body) {
        const compactMode = obj.contentRect.width <= this.compactWith;
        if (this.state.compactMode != compactMode) {
          this.setState({ compactMode });
        }
      }
    }
  }

  getTooltipData(id) {
    return this.store.getTask(id);
  }

  render() {
    const { dataStart, dataEnd, from } = this.state;
    const {
      scrollTop,
      scrollLeft,
      selected,
      details,
      columnsData,
      compactMode,
    } = this.state;
    const { tasks, links, scales, tasksMap } = this.store.state;
    const { grid, cellWidth, cellHeight, readonly } = this.props;
    const { templates, markers, taskTypes, tooltip, borders } = this.props;

    const gridWidth = compactMode ? 50 : grid.width || 400;

    const noDrag = readonly.noDrag || readonly;
    const noEdit = readonly.noEdit || readonly;
    const noNewLink = readonly.noNewLink || readonly;

    const fullWidth = scales.width;
    const fullHeight = tasks.length * cellHeight;

    const renderTasks = tasks.slice(dataStart, dataEnd);

    const { start, diff } = scales;

    const markersData = markers.map((marker) => ({
      id: uid(),
      ...marker,
      left: diff(marker.start, start) * cellWidth,
    }));

    return (
      <Tooltip content={tooltip} data={this.getTooltipData.bind(this)}>
        <div className={css.layout}>
          {grid && (
            <Grid
              compactMode={compactMode}
              width={gridWidth}
              tasks={renderTasks}
              columns={columnsData}
              scales={scales}
              scrollTop={scrollTop}
              scrollDelta={from}
              cellHeight={cellHeight}
              selected={selected}
              action={(ev) => this.action(ev)}
            />
          )}

          <div className={css.content}>
            <TimeScale scales={scales} scrollLeft={scrollLeft} />

            <Chart
              drag={!noDrag}
              newLink={!noNewLink}
              markers={markersData}
              tasks={renderTasks}
              links={links}
              scrollTop={scrollTop}
              scrollLeft={scrollLeft}
              selected={selected}
              cellWidth={cellWidth}
              cellHeight={cellHeight}
              fullWidth={fullWidth}
              fullHeight={fullHeight}
              templates={templates}
              borders={borders}
              action={(ev) => this.action(ev)}
            />
          </div>

          {details && !noEdit && (
            <Sidebar
              compactMode={compactMode}
              taskTypes={taskTypes}
              templates={templates}
              task={details}
              links={links}
              tasksMap={tasksMap}
              action={(ev) => this.action(ev)}
            />
          )}

          {compactMode && !details && (
            <div className={css.icon}>
              <IconButton
                icon="mdi mdi-plus"
                click={() => this.action({ action: "add-task", id: 0 })}
              />
            </div>
          )}
        </div>
      </Tooltip>
    );
  }
}

Gantt.defaultProps = {
  templates: {},
  markers: [],
  taskTypes: ["task", "milestone"],
  tasks: [],
  links: [],
  scales: [
    { unit: "month", step: 1, format: "MMMM yyy" },
    { unit: "day", step: 1, format: "d" },
  ],
  columns: [
    { name: "text", label: "Task name", width: "100%" },
    { name: "add-task", label: "", width: "50px", align: "center" },
  ],
  start: null,
  end: null,
  cellWidth: 100,
  cellHeight: 38,
  scaleHeight: 30,
  readonly: false,
  grid: true,
  tooltip: null,
  borders: "full",
};

export default Gantt;

function onPropsChange(prev, props, cb, allowe) {
  var cached = true;
  for (var key in props) {
    if (prev[key] !== props[key] && (!allowe || allowe[key])) {
      cached = false;
      break;
    }
  }

  if (!cached) cb();
}
